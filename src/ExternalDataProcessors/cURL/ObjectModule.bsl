// @strict-types

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ОписаниеПеременных

Перем ПутьКИсполняемомуФайлу; // Строка
Перем НаборШифров; // Массив из Строка
Перем ЗаголовкиЗапроса; // Соответствие из КлючИЗначение
Перем ЗаголовкиОтвета; // Соответствие из КлючИЗначение
Перем КодСостояния; // Число
Перем РежимЭмуляцииБраузера; // Булево
Перем ИнтернетПрокси; // ИнтернетПрокси, Неопределено
Перем ИмяПользователяНаСервере; // Строка
Перем ПарольПользователяНаСервере; // Строка
Перем СпособАутентификацииНаСервере; // Строка
Перем ПеренаправлятьЗапросПоНовомуURI; // Булево
Перем ВыполнятьАутентификациюПриПеренаправленииНаДругойХост; // Булево
Перем ОбновлятьКуки; // Булево
Перем ПутьКРезультату; // Строка
Перем ПутьКЗаголовкамОтвета; // Строка
Перем ПутьКЗаголовкамЗапроса; // Строка
Перем ПутьКТелуЗапроса; // Строка
Перем ВременныеФайлы; // Соответствие из КлючИЗначение
Перем ИменаЗаголовковЗапросаВНижнемРегистре; // Соответствие из КлючИЗначение
Перем СхемаURL; // Строка
Перем ПользовательскиеОпции; // Соответствие из КлючИЗначение

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Получает содержимое по URL.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Get(URL) Экспорт
	Возврат ОтправитьЗапрос(URL, "GET");
КонецФункции

// Получает содержимое по URL в текстовом формате.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  Строка - Содержимое по URL в текстовом формате
Функция GetString(URL) Экспорт
	Возврат Get(URL).ОтветКакТекст();
КонецФункции

// Получает содержимое по URL в формате JSON.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  Произвольный - Содержимое по URL в формате JSON
Функция GetJson(URL) Экспорт
	Возврат Get(URL).ОтветКакJson();
КонецФункции

// Получает содержимое по URL в формате двоичных данных.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  ДвоичныеДанные, Неопределено - Содержимое по URL в формате двоичных данных
Функция GetBinaryData(URL) Экспорт
	Возврат Get(URL).ОтветКакДвоичныеДанные();
КонецФункции

// (HTTP) Отправляет POST запрос.
// 
// Параметры:
//  URL - Строка - URL
//  Данные - Строка - Простой текст, Адрес двоичных данных во временном хранилище 
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Post(URL, Данные = Неопределено) Экспорт
	Возврат ОтправитьЗапрос(URL, "POST", Данные);
КонецФункции

// (HTTP) Отправляет PUT запрос.
// 
// Параметры:
//  URL - Строка - URL
//  Данные - Строка - Простой текст, Адрес двоичных данных во временном хранилище 
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Put(URL, Данные = Неопределено) Экспорт
	Возврат ОтправитьЗапрос(URL, "PUT", Данные);
КонецФункции

// Возвращает путь к файлу результата запроса.
// 
// Возвращаемое значение:
//  Строка, Неопределено - Путь к файлу результата запроса
Функция ОтветКакПутьФайлу() Экспорт
	
	Если Не ЗначениеЗаполнено(ПутьКРезультату) Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	Файл = Новый Файл(ПутьКРезультату);
	Если Файл.Существует() Тогда
		Возврат ПутьКРезультату;
	КонецЕсли;
	
КонецФункции

// Возвращает ответ запроса в формате двоичных данных.
// 
// Параметры:
//  УдалитьИзДисковойПамяти - Булево - Удаляет артефакты из дисковой памяти
// 
// Возвращаемое значение:
//  ДвоичныеДанные, Неопределено - Ответ запроса в формате двоичных данных
Функция ОтветКакДвоичныеДанные(УдалитьИзДисковойПамяти = Истина) Экспорт
	
	ИмяФайла = ОтветКакПутьФайлу();
	
	Результат = Неопределено;
	Если Не ИмяФайла = Неопределено Тогда
		Результат = Новый ДвоичныеДанные(ИмяФайла);
	КонецЕсли;
	
	Если УдалитьИзДисковойПамяти Тогда
		УдалитьАртефакты();
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает ответ запроса в текстовом формате.
// 
// Параметры:
//  УдалитьИзДисковойПамяти - Булево - Удаляет артефакты из дисковой памяти
// 
// Возвращаемое значение:
//  Строка, Неопределено - Ответ запроса в текстовом формате
Функция ОтветКакТекст(УдалитьИзДисковойПамяти = Истина) Экспорт
	
	ИмяФайла = ОтветКакПутьФайлу();
	
	Результат = Неопределено;
	Если Не ИмяФайла = Неопределено Тогда
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.UTF8);
		Результат = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();	
	КонецЕсли;
	
	Если УдалитьИзДисковойПамяти Тогда
		УдалитьАртефакты();
	КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

// Возвращает ответ запроса в формате JSON.
// 
// Параметры:
//  УдалитьИзДисковойПамяти - Булево - Удаляет артефакты из дисковой памяти
// 
// Возвращаемое значение:
//  Произвольный - Ответ запроса в формате JSON
Функция ОтветКакJson(УдалитьИзДисковойПамяти = Истина) Экспорт
		
	ИмяФайла = ОтветКакПутьФайлу();
	
	Результат = Неопределено;
	Если Не ИмяФайла = Неопределено Тогда
		Результат = ПрочитатьФайлJSON(ИмяФайла);
	КонецЕсли;
	
	Если УдалитьИзДисковойПамяти Тогда
		УдалитьАртефакты();
	КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

// Аутентификация на сервере (Basic Authentication).
// 
// Параметры:
//  ИмяПользователя - Строка - Имя пользователя
//  Пароль - Строка - Пароль
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция АутентификацияНаСервере(ИмяПользователя, Пароль) Экспорт
	ИмяПользователяНаСервере = ИмяПользователя;
	ПарольПользователяНаСервере = Пароль;
	СпособАутентификацииНаСервере = СпособАутентификацииНаСервереBasic();
	Возврат ЭтотОбъект();
КонецФункции

// Аутентификация на сервере (Digest Authentication).
// 
// Параметры:
//  ИмяПользователя - Строка - Имя пользователя
//  Пароль - Строка - Пароль
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция АутентификацияНаСервереDigest(ИмяПользователя, Пароль) Экспорт
	ИмяПользователяНаСервере = ИмяПользователя;
	ПарольПользователяНаСервере = Пароль;
	СпособАутентификацииНаСервере = СпособАутентификацииНаСервереDigest();
	Возврат ЭтотОбъект();
КонецФункции

// Устанавливает прокси.
// 
// Параметры:
//  Прокси - ИнтернетПрокси, Неопределено - Прокси
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьПрокси(Прокси) Экспорт
	ИнтернетПрокси = Прокси;
	Возврат ЭтотОбъект();
КонецФункции

// Добавляет шифры в набор.
// 
// Параметры:
//  Шифры - Строка - Шифры
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ДобавитьШифры(Шифры) Экспорт
	//@skip-check invocation-parameter-type-intersect
	ДополнитьМассив(НаборШифров, СтрРазделить(Шифры, ","), Истина);
	Возврат ЭтотОбъект();
КонецФункции

// (HTTP) Устанавливает HTTP заголовки.
// 
// Параметры:
//  Заголовки - Соответствие из КлючИЗначение
//            - Строка - Строка содержащая пары ключ-значение. Значение от ключа должно быть разделено двоеточием. 
//                       Пары должны быть разделены символом переноса.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьЗаголовки(Заголовки) Экспорт
	Если ТипЗнч(Заголовки) = Тип("Соответствие") Тогда
		ЗаголовкиЗапроса = Заголовки;
	Иначе
		ЗаголовкиЗапроса = ЗаголовкиИзТекста(Заголовки);
	КонецЕсли;
	
	ОбновитьИменаЗаголовковВВерхнемРегистре();
	
	Возврат ЭтотОбъект();
КонецФункции

// (HTTP) Устанавливает HTTP заголовок.
// 
// Параметры:
//  Имя - Строка - Имя заголовка
//  Значение - Строка - Значение
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьЗаголовок(Имя, Значение) Экспорт
	
	ИмяИсходное = ИменаЗаголовковЗапросаВНижнемРегистре.Получить(НРег(Имя)); // Строка
	Если ИмяИсходное = Неопределено Тогда
		ИмяИсходное = Имя;	
	КонецЕсли;
		
	ЗаголовкиЗапроса.Вставить(ИмяИсходное, Значение);	
	ИменаЗаголовковЗапросаВНижнемРегистре.Вставить(НРег(ИмяИсходное), ИмяИсходное);
	
	Возврат ЭтотОбъект();

КонецФункции

// (HTTP) Возвращает значение заголовка запроса.
// 
// Параметры:
//  Имя - Строка - Имя заголовка запроса
// 
// Возвращаемое значение:
//  Строка - Значение заголовка запроса
Функция Заголовок(Имя) Экспорт
	ИмяИсходное = ИменаЗаголовковЗапросаВНижнемРегистре.Получить(НРег(Имя)); // Строка
	
	Если ИмяИсходное = Неопределено Тогда
		Возврат "";	
	КонецЕсли;
	
	Значение = ЗаголовкиЗапроса.Получить(ИмяИсходное);
	Если Значение = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Значение;	
КонецФункции

// (HTTP) Возвращает значение заголовка ответа.
// 
// Параметры:
//  Имя - Строка - Имя заголовка ответа
// 
// Возвращаемое значение:
//  Строка, Массив из Строка, Неопределено - Значение заголовка ответа
Функция ЗаголовокОтвета(Имя) Экспорт
	Возврат ЗаголовкиОтвета.Получить(НРег(Имя));	
КонецФункции

// (HTTP) Заголовки ответа.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - Заголовки ответа:
//  	* Ключ - Строка - Имя заголовка
//  	* Значение - Строка, Массив из Строка - Значение(я) заголовка
Функция ЗаголовкиОтвета() Экспорт
	//@skip-check invocation-parameter-type-intersect
	Возврат СкопироватьСоответствие(ЗаголовкиОтвета);
КонецФункции

// (HTTP) Возвращает куки.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - Куки
Функция Куки() Экспорт
	
	Куки = Новый Соответствие();
	Массив = СтрРазделить(КукиСтрокой(), ";"); // Массив из Строка
	
	Для Каждого КлючИЗначениеСтрока Из Массив Цикл
		
		ПозицияРавенства = СтрНайти(КлючИЗначениеСтрока, "=");
		
		Если ПозицияРавенства Тогда
			Имя = СокрЛП(Сред(КлючИЗначениеСтрока, 1, ПозицияРавенства - 1));
			Значение = СокрЛП(Сред(КлючИЗначениеСтрока, ПозицияРавенства + 1));
			Куки.Вставить(Имя, Значение);
		Иначе
			Куки.Вставить(КлючИЗначениеСтрока);
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат Куки;
	
КонецФункции

// (HTTP) Возвращает куки строкой.
// 
// Возвращаемое значение:
//  Строка - Куки
Функция КукиСтрокой() Экспорт
	Возврат Заголовок("Cookie");
КонецФункции

// (HTTP) Устанавливает куки.
// 
// Параметры:
//  Куки - Строка - Куки
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьКуки(Куки) Экспорт
	УстановитьЗаголовок("Cookie", Куки);
	Возврат ЭтотОбъект();	
КонецФункции

// (HTTP) Дополнять куки значениями Set-Cookie из заголовков ответа
// 
// Параметры:
//  Обновлять - Булево - Обновлять
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ОбновлятьКуки(Обновлять = Истина) Экспорт
	ОбновлятьКуки = Обновлять;
	Возврат ЭтотОбъект();
КонецФункции

// (HTTP) Куки дополняются значениями Set-Cookie из заголовков ответа
Процедура ОбновитьКуки() Экспорт
	
	Если Не ЭтоHTTP() Тогда
		Возврат;
	КонецЕсли;
	
	КукиСтрокой = Заголовок("Cookie");
	НовыеКукиСтрокой = КукиИзОтветаСтрокой();
		
	Если Не ПустаяСтрока(НовыеКукиСтрокой) Тогда
		КукиСтрокой = КукиСтрокой 
			+ ?(ПустаяСтрока(КукиСтрокой), "", "; ")
			+ НовыеКукиСтрокой;
					
		УстановитьЗаголовок("Cookie", КукиСтрокой);
	КонецЕсли;
	
КонецПроцедуры

// (HTTP) Возвращает куки полученые из заголовка ответа Set-Cookie.
// 
// Возвращаемое значение:
//  Массив из см. НоваяЗаписьКуки
Функция КукиИзОтвета() Экспорт
	
	Куки = Новый Массив; // Массив из см. НоваяЗаписьКуки

	СтрокиУстановкиКуки = ЗаголовокОтвета("Set-Cookie");
	
	Если ТипЗнч(СтрокиУстановкиКуки) = Тип("Массив") Тогда
		Для Каждого Строка Из СтрокиУстановкиКуки Цикл
			ЗаписьКуки = ДесериализоватьSetCookie(Строка);
			Если ЗаписьКуки <> Неопределено Тогда
				Куки.Добавить(ЗаписьКуки);	
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(СтрокиУстановкиКуки) = Тип("Строка") Тогда
		ЗаписьКуки = ДесериализоватьSetCookie(СтрокиУстановкиКуки);
		Если ЗаписьКуки <> Неопределено Тогда
			Куки.Добавить(ЗаписьКуки);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Куки;
	
КонецФункции

// (HTTP) Возвращает куки полученые из заголовка ответа Set-Cookie строкой.
// 
// Возвращаемое значение:
//  Строка - Куки из ответа строкой
Функция КукиИзОтветаСтрокой() Экспорт
	
	КукиСтрокой = "";
	Для Каждого Запись Из КукиИзОтвета() Цикл
		КукиСтрокой = КукиСтрокой 
			+ СтрШаблон("%1%2=%3", 
				?(КукиСтрокой = "", "", "; "),
				Запись["Name"],
				Запись["Value"]);
	КонецЦикла;
	
	Возврат КукиСтрокой;
	
КонецФункции

// (HTTP) Перенаправит запрос по новому Location, если сервер вернул ответ с кодом состояния 3XX.
// 
// Параметры:
//  Перенаправлять - Булево - Перенаправлять
//  ВыполнятьАутентификациюНаДругомХосте - Булево - Выполнять аутентификацию при перенаправлении на другой хост
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ПеренаправлятьЗапрос(Перенаправлять = Истина, ВыполнятьАутентификациюНаДругомХосте = Ложь) Экспорт
	ПеренаправлятьЗапросПоНовомуURI = Перенаправлять;
	ВыполнятьАутентификациюПриПеренаправленииНаДругойХост = ВыполнятьАутентификациюНаДругомХосте;
	Возврат ЭтотОбъект();
КонецФункции

// (HTTP) Эмуляция Сhrome.
// 
// Параметры:
//  Включить - Булево - Включить эмуляцию
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ЭмуляцияБраузера(Включить = Истина) Экспорт
	РежимЭмуляцииБраузера = Включить;
	Возврат ЭтотОбъект();
КонецФункции

// (HTTP, FTP) Код состояния.
// 
// Возвращаемое значение:
//  Число - Код состояния
Функция КодСостояния() Экспорт
	Возврат КодСостояния;
КонецФункции

// Очищает артефакты запроса и восстанавливает исходные настройки.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Закрыть() Экспорт
	УдалитьАртефакты();
	УстановитьНачальныеНастройки();
	Возврат ЭтотОбъект();
КонецФункции

// Установить исполняемый файл.
// 
// Параметры:
//  Путь - Строка - Путь
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УказатьИсполняемыйФайл(Путь) Экспорт
	ПутьКИсполняемомуФайлу = Путь;
	Возврат ЭтотОбъект();
КонецФункции

// Добавляет опцию команды curl.
// 
// Параметры:
//  Имя - Строка - Имя опции
//  Значение - Строка - Значение опции
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ДобавитьОпцию(Имя, Значение = "") Экспорт
	ДобавитьОпциюВСписок(ПользовательскиеОпции, Имя, Значение);
	Возврат ЭтотОбъект();
КонецФункции

// Удаляет опцию команды curl.
// 
// Параметры:
//  Имя - Строка - Имя опции
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УдалитьОпцию(Знач Имя) Экспорт
	Имя = НРег(СокрЛП(Имя));
	ПользовательскиеОпции.Удалить(Имя);
	Возврат ЭтотОбъект();
КонецФункции

// Очищает опции команды curl.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ОчиститьОпции() Экспорт
	ПользовательскиеОпции = Новый Соответствие();
	Возврат ЭтотОбъект();	
КонецФункции

// Собирает консольную команду curl.
// 
// Параметры:
//  URL - Строка - URL
//  Метод - Строка - Метод (GET, POST, PUT и т.д.)
//  Данные - Строка - Простой текст, Адрес двоичных данных во временном хранилище
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
// 
// Возвращаемое значение:
//  Строка - Консольная команда curl
Функция СобратьКоманду(URL, Метод = "", Данные = Неопределено) Экспорт
	
	Опции = Новый Соответствие();
	ДополнитьСоответствие(Опции, ПользовательскиеОпции);
	
	Если РежимЭмуляцииБраузера Тогда
		ЭмуляцияChrome(Опции);
	КонецЕсли;
	
	ДобавитьОпциюURL(Опции, URL);
	ДобавитьОпциюМетодЗапроса(Опции, Метод);
	ДобавитьОпциюШифры(Опции);
	ДобавитьОпциюЗаголовки(Опции);
	ДобавитьОпциюФайлДампаЗаголовков(Опции);
	ДобавитьОпциюПрокси(Опции);
	ДобавитьОпциюДанныеАутентификации(Опции);
	ДобавитьОпциюПеренаправлениеЗапроса(Опции);	
	ДобавитьОпциюДанныеЗапросаБезопасно(Опции, Данные);
	ДобавитьОпциюПутьКВыходномуФайлу(Опции);
	ДобавитьОпциюВСписок(Опции, "--silent");
	
	СтрокаКоманды = СтрШаблон("%1 %2", ИмяКоманды(), ОпцииВСтроку(Опции));
		
	Возврат СтрокаКоманды;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура УстановитьНачальныеНастройки()
	
	КодСостояния = 0;
	ИнтернетПрокси = Неопределено;
	
	ИмяПользователяНаСервере = "";
	ПарольПользователяНаСервере = "";
	СпособАутентификацииНаСервере = "";
	ПеренаправлятьЗапросПоНовомуURI = Ложь;
	ВыполнятьАутентификациюПриПеренаправленииНаДругойХост = Ложь;
	ОбновлятьКуки(Истина);
	
	НаборШифров = Новый Массив;
	ЗаголовкиЗапроса = Новый Соответствие();
	ЗаголовкиОтвета = Новый Соответствие();
	ИменаЗаголовковЗапросаВНижнемРегистре = Новый Соответствие();
	ОчиститьОпции();
	
	ВременныеФайлы = Новый Соответствие();
	
	ЭмуляцияБраузера(Ложь);
	
КонецПроцедуры

// Отправляет запрос.
// 
// Параметры:
//  URL - Строка - URL
//  Метод - Строка - Метод
//  Данные - Строка - Простой текст, Адрес двоичных данных во временном хранилище
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ОтправитьЗапрос(URL, Метод, Данные = Неопределено)

	КодСостояния = 0;
	ЗаголовкиОтвета.Очистить();
	
	УдалитьАртефакты();	
	ПрочитатьСхемуURL(URL);
	
	Команда = СобратьКоманду(URL, Метод, Данные);
	ВыполнитьКоманду(Команда);
	
	ПрочитатьЗаголовкиОтвета();
	
	Если ОбновлятьКуки Тогда
		ОбновитьКуки();
	КонецЕсли;
	
	Возврат ЭтотОбъект();
	
КонецФункции

Процедура ВыполнитьКоманду(СтрокаКоманды)
	
	Попытка
		РезультатЗапуска = ЗапуститьПрограмму(СтрокаКоманды);
			
		Если Не ПустаяСтрока(РезультатЗапуска.ПотокОшибок) Тогда
			ВызватьИсключение РезультатЗапуска.ПотокОшибок;		
		КонецЕсли;		
	Исключение
		УдалитьАртефакты();
		
		ТекстОшибки = СтрШаблон("Не удалось выполнить команду curl: 
		|%1", ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
				
	УдалитьФайлЕслиСуществует(ПутьКЗаголовкамЗапроса);
	УдалитьФайлЕслиСуществует(ПутьКТелуЗапроса);
	УдалитьФайлЕслиПустой(ПутьКРезультату);
	
КонецПроцедуры

// Запускает внешнюю программу на исполнение с ожиданием завершения
//
// Параметры:
//  СтрокаКоманды  - Строка - командная строка для запуска программы.
//
// Возвращаемое значение:
//  Структура:
//    * КодВозврата - Число, Неопределено  - код возврата программы;
//    * ПотокОшибок - Строка - ошибки исполнения программы, направленные в поток stderr.
Функция ЗапуститьПрограмму(Знач СтрокаКоманды) 
	
	КодВозврата = Неопределено; // Число, Неопределено
		
	ИмяФайлаПотокаОшибок = НовоеИмяВременногоФайла("stderr.tmp");
	СтрокаКоманды = СтрокаКоманды + " 2>" + ОбернутьКавычками(ИмяФайлаПотокаОшибок);
	
	Если ЭтоWindows() Тогда
		Кодировка = КодировкаТекста.OEM;
			
		СтрокаКоманды = СтрШаблон("(chcp 866) && (%1)", СтрокаКоманды);
		СтрокаКоманды = "cmd /S /C " + ОбернутьКавычками(СтрокаКоманды);
	
		Если ИнформационнаяБазаФайловая() Тогда
			// В файловой информационной базе показывать окно консоли не следует и в серверном контексте.
			Попытка
				Оболочка = Новый COMОбъект("Wscript.Shell");
				КодВозврата = Оболочка.Run(СтрокаКоманды, 0, Истина); // Число, Неопределено
				Оболочка = Неопределено;
			Исключение
				Оболочка = Неопределено;
				
				ТекстОшибки = СтрШаблон("Не удалось запустить программу: 
				|%1", ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;	
		Иначе
			ЗапуститьПриложение(СтрокаКоманды,, Истина, КодВозврата);
		КонецЕсли;
		
	Иначе	
		Кодировка = КодировкаТекста.UTF8;
		ЗапуститьПриложение(СтрокаКоманды,, Истина, КодВозврата);
	КонецЕсли;

	Ошибки = ПрочитатьФайлЕслиСуществует(ИмяФайлаПотокаОшибок, Кодировка);
	УдалитьФайлЕслиСуществует(ИмяФайлаПотокаОшибок);
	
	Результат = Новый Структура;
	Результат.Вставить("КодВозврата", КодВозврата);
	Результат.Вставить("ПотокОшибок", Ошибки);
	
	Возврат Результат;
	
КонецФункции

// (HTTP, FTP) Читает файл с заголовками ответа.
Процедура ПрочитатьЗаголовкиОтвета()
			
	ЗаголовкиОтвета.Очистить();
	
	Если ЭтоHTTP() Тогда
		ПрочитатьЗаголовкиОтветаHTTP();	
	ИначеЕсли ЭтоFTP() Тогда
		ПрочитатьЗаголовкиОтветаFTP();
	КонецЕсли;
	
	УдалитьФайлЕслиСуществует(ПутьКЗаголовкамОтвета);
		
КонецПроцедуры

Процедура ПрочитатьЗаголовкиОтветаHTTP()
	
	Если Не ЗначениеЗаполнено(ПутьКЗаголовкамОтвета) Тогда
		Возврат;	
	КонецЕсли;
	
	Текст = Новый ЧтениеТекста(ПутьКЗаголовкамОтвета, КодировкаТекста.UTF8);
	
	Строка = Текст.ПрочитатьСтроку();
	Пока Строка <> Неопределено Цикл
		
		Если СтрНайти(Строка, "HTTP/") = 1 Тогда
			Подстроки = СтрРазделить(Строка, " ");
			КодСостояния = Число(Подстроки[1]);
			ЗаголовкиОтвета.Очистить();
		КонецЕсли;
		
		ПозицияДвоеточия = СтрНайти(Строка, ":");
		Если ПозицияДвоеточия Тогда
			ИмяЗаголовка = НРег(Сред(Строка, 1, ПозицияДвоеточия - 1));
			Значение = СокрЛП(Сред(Строка, ПозицияДвоеточия + 1));
			
			Если ЗаголовкиОтвета.Получить(ИмяЗаголовка) = Неопределено Тогда
				ЗаголовкиОтвета.Вставить(ИмяЗаголовка, Значение);
			ИначеЕсли ТипЗнч(ЗаголовкиОтвета[ИмяЗаголовка]) = Тип("Массив") Тогда
				МассивЗначений = ЗаголовкиОтвета[ИмяЗаголовка]; // Массив из Строка
				МассивЗначений.Добавить(Значение);
			Иначе
				ПервоеЗначение = ЗаголовкиОтвета[ИмяЗаголовка]; // Строка
				МассивЗначений = Новый Массив; // Массив из Строка
				МассивЗначений.Добавить(ПервоеЗначение);
				МассивЗначений.Добавить(Значение);
				ЗаголовкиОтвета.Вставить(ИмяЗаголовка, МассивЗначений);
			КонецЕсли;

		КонецЕсли;
		
		Строка = Текст.ПрочитатьСтроку();	
	КонецЦикла;
	
	Текст.Закрыть();
		
КонецПроцедуры

Процедура ПрочитатьЗаголовкиОтветаFTP()
	
	Если Не ЗначениеЗаполнено(ПутьКЗаголовкамОтвета) Тогда
		Возврат;	
	КонецЕсли;
	
	Текст = Новый ТекстовыйДокумент();
	Текст.Прочитать(ПутьКЗаголовкамОтвета, КодировкаТекста.UTF8);
	
	КоличествоСтрок = Текст.КоличествоСтрок();
	Если КоличествоСтрок > 0 Тогда
		ПоследняяСтрока = Текст.ПолучитьСтроку(КоличествоСтрок);
		Код = Лев(ПоследняяСтрока, 3);
		Если ТолькоЦифрыВСтроке(Код) Тогда
			КодСостояния = Число(Код);
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// (HTTP) Парсит заголовки из текста. 
// Текст должен содежрать пары ключ-значение. Значение от ключа должно быть разделено двоеточием. 
// Пары должны быть разделены символом переноса.
// 
// Параметры:
//  Текст - Строка - Текст
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение
Функция ЗаголовкиИзТекста(Текст)
	
	Заголовки = Новый Соответствие();
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(Текст) Цикл
		
		Строка = СтрПолучитьСтроку(Текст, НомерСтроки);
		ПозицияДвоеточия = СтрНайти(Строка, ":");
		Если ПозицияДвоеточия Тогда
			Имя = СокрЛП(Сред(Строка, 1, ПозицияДвоеточия - 1));
			Значение = СокрЛП(Сред(Строка, ПозицияДвоеточия + 1));
			Заголовки.Вставить(Имя, Значение);
		КонецЕсли;
				
	КонецЦикла;
	
	Возврат Заголовки;
	
КонецФункции

Процедура ОбновитьИменаЗаголовковВВерхнемРегистре()
	
	ИменаЗаголовковЗапросаВНижнемРегистре.Очистить();
	
	Для Каждого КлючИЗначение Из ЗаголовкиЗапроса Цикл
		ИмяЗаголовка = КлючИЗначение.Ключ; // Строка
		ИменаЗаголовковЗапросаВНижнемРегистре.Вставить(НРег(ИмяЗаголовка), ИмяЗаголовка);
	КонецЦикла;
	
КонецПроцедуры

// Преобразует структуру в тело запроса.
// 
// Параметры:
//  Тело	- Структура
//  		- Соответствие из КлючИЗначение
// 
// Возвращаемое значение:
//  Строка
Функция СтруктураВТелоЗапроса(Тело)

	ТелоЗапроса = "";

	Для Каждого КлючИЗначение Из Тело Цикл	
		Значение = КодироватьСтроку(XMLСтрока(КлючИЗначение.Значение), СпособКодированияСтроки.КодировкаURL);

		ТелоЗапроса = ТелоЗапроса 
			+ ?(ТелоЗапроса = "", "", "&")
			+ КлючИЗначение.Ключ + "=" + Значение;	
	КонецЦикла;	
	
	Возврат ТелоЗапроса;
	
КонецФункции

Функция СпособАутентификацииНаСервереBasic()
	Возврат "basic";	
КонецФункции

Функция СпособАутентификацииНаСервереDigest()
	Возврат "digest";	
КонецФункции

// Обернуть кавычками строку.
// 
// Параметры:
//  Строка - Строка - Строка
// 
// Возвращаемое значение:
//  Строка - Обернуть кавычками
Функция ОбернутьКавычками(Строка)
	Возврат """" + Строка + """";
КонецФункции

Функция ЭтоHTTP()
	Возврат СхемаURL = "HTTP" Или СхемаURL = "HTTPS";
КонецФункции

Функция ЭтоFTP()
	Возврат СхемаURL = "FTP";
КонецФункции

Процедура ПрочитатьСхемуURL(URL)
	СхемаURL = ПолучитьСхемуURL(URL);
КонецПроцедуры

// Возвращает схему URL.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  Строка - схема URL
Функция ПолучитьСхемуURL(URL)
	
	Схема = "";
	Позиция = СтрНайти(URL, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(URL, Позиция - 1));
	КонецЕсли;
	
	Возврат ВРег(Схема);
		
КонецФункции

// Этот объект.
// 
// Возвращаемое значение:
//  ОбработкаОбъект.cURL, ВнешняяОбработка.cURL - Этот объект
//@skip-check doc-comment-type
Функция ЭтотОбъект()
	Возврат ЭтотОбъект;
КонецФункции

#Область РаботаСФайлами

// Возвращает имя временного файла.
// 
// Параметры:
//  Расширение - Строка - Расширение файла
// 
// Возвращаемое значение:
//  Строка - имя временного файла
Функция НовоеИмяВременногоФайла(Расширение = "")
	//@skip-check missing-temporary-file-deletion
	Имя = ПолучитьИмяВременногоФайла(Расширение);
	ВременныеФайлы.Вставить(Имя);
	Возврат Имя;
КонецФункции

// Удаляет артефакты выполнения запроса.
Процедура УдалитьАртефакты()
	
	Для Каждого Строка Из ВременныеФайлы Цикл
		Путь = Строка.Ключ; // Строка
		УдалитьФайлЕслиСуществует(Путь);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет файл, если существует.
// 
// Параметры:
//  Путь - Строка - Путь к файлу
Процедура УдалитьФайлЕслиСуществует(Путь)
	
	Если Не ЗначениеЗаполнено(Путь) Тогда
		Возврат;
	КонецЕсли;
	
	Файл = Новый Файл(Путь);
	Если Файл.Существует() Тогда
		УдалитьФайлы(Путь);	
	КонецЕсли;
	
	ВременныеФайлы.Удалить(Путь);
	
	Путь = "";
	
КонецПроцедуры

// Удаляет файл если пустой.
// 
// Параметры:
//  Путь - Строка - Путь к файлу
Процедура УдалитьФайлЕслиПустой(Путь)
	
	Если Не ЗначениеЗаполнено(Путь) Тогда
		Возврат;
	КонецЕсли;
		
	Файл = Новый Файл(Путь);
	Если Файл.Существует() Тогда
		Если Файл.Размер() = 0 Тогда
			УдалитьФайлЕслиСуществует(Путь);	
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Путь = "";

КонецПроцедуры

// Возвращает содержимое файла.
// 
// Параметры:
//  Путь - Строка - Путь
//  Кодировка - КодировкаТекста - Кодировка
// 
// Возвращаемое значение:
//  Строка - Содержимое файла
Функция ПрочитатьФайлЕслиСуществует(Путь, Кодировка)
	
	Результат = "";
	ФайлИнфо = Новый Файл(Путь);
	
	Если ФайлИнфо.Существует() Тогда 
		
		ЧтениеПотокаОшибок = Новый ЧтениеТекста(Путь, Кодировка);
		Результат = ЧтениеПотокаОшибок.Прочитать();
		ЧтениеПотокаОшибок.Закрыть();
		
	КонецЕсли;
	
	Если Результат = Неопределено Тогда 
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Прочитать файл JSON.
// 
// Параметры:
//  ПутьКФайлу - Строка - Путь к файлу
// 
// Возвращаемое значение:
//  Произвольный
Функция ПрочитатьФайлJSON(ПутьКФайлу)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ПутьКФайлу);
	
	Результат = ПрочитатьJSON(ЧтениеJSON, Истина);

	ЧтениеJSON.Закрыть();
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПодготовкаКоманды
	
// Возвращает имя команды curl.
// 
// Возвращаемое значение:
//  Строка - Имя команды curl
Функция ИмяКоманды()

	Если ЗначениеЗаполнено(ПутьКИсполняемомуФайлу) Тогда
		Имя = ОбернутьКавычками(ПутьКИсполняемомуФайлу);
	Иначе
		Имя = "curl";
	КонецЕсли;
		
	Возврат Имя;
	
КонецФункции

// Добавляет URL в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
//  URL - Строка - URL
Процедура ДобавитьОпциюURL(Опции, URL)
	ДобавитьОпциюВСписок(Опции, "--url", URL);	
КонецПроцедуры

// Добавляет метод запроса в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
//  Метод - Строка - Метод
Процедура ДобавитьОпциюМетодЗапроса(Опции, Метод)
	
	Если Метод = "GET" Тогда
		Возврат;	
	КонецЕсли;
	
	ДобавитьОпциюВСписок(Опции, "--request", Метод);
	
КонецПроцедуры

// Добавляет заголовки в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюЗаголовки(Опции)
	
	Если Не ЭтоHTTP() Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗаголовкиЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЗаголовкиТекст = "";
	Для Каждого КлючИЗначение Из ЗаголовкиЗапроса Цикл
		ЗаголовкиТекст = ЗаголовкиТекст 
			+ СтрШаблон("%1: %2", КлючИЗначение.Ключ, КлючИЗначение.Значение)
			+ Символы.ПС;	
	КонецЦикла;
	
	ПутьКЗаголовкамЗапроса = НовоеИмяВременногоФайла();
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент();
	ТекстовыйДокумент.УстановитьТекст(ЗаголовкиТекст);
	ТекстовыйДокумент.Записать(ПутьКЗаголовкамЗапроса, "CESU-8");
	
	ДобавитьОпциюВСписок(Опции, "--header", "@" + ПутьКЗаголовкамЗапроса);
	
КонецПроцедуры

// Добавляет шифры в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюШифры(Опции)
	
	Если Не НаборШифров.Количество() Тогда
		Возврат;
	КонецЕсли;
		
	Шифры = СтрСоединить(НаборШифров, ",");
	ДобавитьОпциюВСписок(Опции, "--ciphers", Шифры);
	
КонецПроцедуры

// Добавляет безопасно данные запроса в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
//  Данные - Строка - Простой текст, Адрес двоичных данных во временном хранилище
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
Процедура ДобавитьОпциюДанныеЗапросаБезопасно(Опции, Данные)

	Если Не Данные = Неопределено Тогда
		Попытка
			ДобавитьОпциюДанныеЗапроса(Опции, Данные);
		Исключение
			УдалитьАртефакты();
			
			ТекстОшибки = СтрШаблон("Не удалось подготовить данные для запроса: 
			|%1", ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
			ВызватьИсключение ТекстОшибки;			
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры
	
// Добавляет данные запроса в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
//  Данные - Строка - Простой текст, Адрес двоичных данных во временном хранилище
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
Процедура ДобавитьОпциюДанныеЗапроса(Опции, Данные)
	
	Если Данные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если ТипЗнч(Данные) = Тип("Строка") И ЭтоАдресВременногоХранилища(Данные) Тогда
		ОбработанныеДанные = ПолучитьИзВременногоХранилища(Данные);	
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура") Или ТипЗнч(Данные) = Тип("Соответствие") Тогда		
		ОбработанныеДанные = СтруктураВТелоЗапроса(Данные);	
	Иначе
		ОбработанныеДанные = Данные;
	КонецЕсли;
	
	Если ТипЗнч(ОбработанныеДанные) = Тип("ДвоичныеДанные") Тогда		
		ПутьКТелуЗапроса = НовоеИмяВременногоФайла();	
		ОбработанныеДанные.Записать(ПутьКТелуЗапроса);
		ОбработанныеДанные = Неопределено;
		ОбработанныеДанные = Новый Файл(ПутьКТелуЗапроса);
	КонецЕсли;	
		
	Если ТипЗнч(ОбработанныеДанные) = Тип("Файл") Тогда
		
		Если ОбработанныеДанные.Существует() Тогда
			Если ЭтоHTTP() Тогда
				ДобавитьОпциюВСписок(Опции, "--data-binary", "@" + ОбработанныеДанные.ПолноеИмя);
			Иначе
				ДобавитьОпциюВСписок(Опции, "--upload-file", "@" + ОбработанныеДанные.ПолноеИмя);
			КонецЕсли;
		Иначе
			ВызватьИсключение СтрШаблон("Файл '%1' не существует", ОбработанныеДанные.ПолноеИмя);
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(ОбработанныеДанные) = Тип("Строка") Тогда
		
		ДобавитьОпциюВСписок(Опции, "--data-raw", ОбработанныеДанные);
		
	Иначе
		
		ВызватьИсключение СтрШаблон("Тип %1 не поддерживается в качестве тела запроса", ТипЗнч(Данные));
		
	КонецЕсли;
					
КонецПроцедуры

// (HTTP, FTP) Добавляет файл дампа заголовков в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюФайлДампаЗаголовков(Опции)
	
	Если Не (ЭтоHTTP() Или ЭтоFTP())Тогда
		Возврат;
	КонецЕсли;
	
	ПутьКЗаголовкамОтвета = НовоеИмяВременногоФайла();
	ДобавитьОпциюВСписок(Опции, "--dump-header", ПутьКЗаголовкамОтвета);
	
КонецПроцедуры

// Добавляет прокси в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюПрокси(Опции)
	
	Если ИнтернетПрокси = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Протокол = "http";
	Если ИнтернетПрокси.Порт() = 443 Тогда
		Протокол = "https";	
	КонецЕсли;
	
	ДобавитьОпциюВСписок(Опции, "--proxy", СтрШаблон("%1://%2", Протокол, ИнтернетПрокси.Сервер()));
	
	Если ЗначениеЗаполнено(ИнтернетПрокси.Пользователь) Тогда
		ДобавитьОпциюВСписок(Опции, "--proxy-user", СтрШаблон("%1:%2", ИнтернетПрокси.Пользователь, ИнтернетПрокси.Пароль));	
	КонецЕсли;
	
КонецПроцедуры

// Добавляет данные аутентификации на сервере в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюДанныеАутентификации(Опции)
	
	Если Не ЗначениеЗаполнено(ИмяПользователяНаСервере) Тогда
		Возврат;
	КонецЕсли;
	
	ДобавитьОпциюВСписок(Опции, "--user", СтрШаблон("%1:%2", ИмяПользователяНаСервере, ПарольПользователяНаСервере));
 
 	Если СпособАутентификацииНаСервере = СпособАутентификацииНаСервереDigest() Тогда
 		ДобавитьОпциюВСписок(Опции, "--digest");
 	Иначе
 		ДобавитьОпциюВСписок(Опции, "--basic");
 	КонецЕсли;
 	
КонецПроцедуры

// (HTTP) Добавляет перенаправление запроса в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюПеренаправлениеЗапроса(Опции)
	
	Если Не ЭтоHTTP() Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ПеренаправлятьЗапросПоНовомуURI Тогда
		Возврат;
	КонецЕсли;
	
	Если ВыполнятьАутентификациюПриПеренаправленииНаДругойХост Тогда
		ДобавитьОпциюВСписок(Опции, "--location-trusted");	
	Иначе
		ДобавитьОпциюВСписок(Опции, "--location");	
	КонецЕсли;
 	
КонецПроцедуры

// Добавляет путь к выходному файлу в список опций команды.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ДобавитьОпциюПутьКВыходномуФайлу(Опции)
	ПутьКРезультату = НовоеИмяВременногоФайла();
	ДобавитьОпциюВСписок(Опции, "--output", ПутьКРезультату);
КонецПроцедуры

// Добавляет опцию в список.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции
//  Имя - Строка - Имя опции
//  Значение - Строка - Значение опции
Процедура ДобавитьОпциюВСписок(Опции, Знач Имя, Значение = "")	
	Имя = НРег(СокрЛП(Имя));	
	Опции.Вставить(Имя, Значение);		
КонецПроцедуры

// Конвертирует опции команды curl в строку.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
// 
// Возвращаемое значение:
//  Строка
Функция ОпцииВСтроку(Опции)
	
	СтрокаОпций = "";
	Для Каждого КлючИЗначение Из Опции Цикл

		СтрокаОпций = СтрокаОпций 
			+ ?(СтрокаОпций = "", "", " ")
			+ КлючИЗначение.Ключ;
			
		Значение = КлючИЗначение.Значение; // Строка
		Если ЗначениеЗаполнено(Значение) Тогда
			СтрокаОпций = СтрокаОпций + " " + ОбернутьКавычками(Значение);	
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрокаОпций;
	
КонецФункции

#КонецОбласти

#Область Куки

// Десериализовывает значение заголовка ответа Set-Cookie.
// 
// Параметры:
//  Строка - Строка - Значение заголовка Set-Cookie
// 
// Возвращаемое значение:
//  см. НоваяЗаписьКуки
Функция ДесериализоватьSetCookie(Строка)
	
	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСтрокАтрибутов = СтрРазделить(Строка, ";");
	
	ЗаписьКуки = НоваяЗаписьКуки();
	
	Для Каждого СтрокаАтрибута Из МассивСтрокАтрибутов Цикл
		ПозицияРавенства = СтрНайти(СтрокаАтрибута, "=");
		
		ЗначениеАтрибута = ""; // Строка, Булево
		Если ПозицияРавенства Тогда
			ИмяАтрибута = СокрЛП(Сред(СтрокаАтрибута, 1, ПозицияРавенства - 1));	
			ЗначениеАтрибута = СокрЛП(Сред(СтрокаАтрибута, ПозицияРавенства + 1));
		Иначе
			ИмяАтрибута = СокрЛП(СтрокаАтрибута);
			ЗначениеАтрибута = Истина;
		КонецЕсли;
			
		Если ЭтоАтрибутКуки(ИмяАтрибута) Тогда
			ЗаписьКуки[НормализованноеИмяАтрибутаКуки(ИмяАтрибута)] = ЗначениеАтрибута;
		ИначеЕсли Не ЗначениеЗаполнено(ЗаписьКуки["Name"]) Тогда
			ЗаписьКуки["Name"] = ИмяАтрибута;
			ЗаписьКуки["Value"] = ЗначениеАтрибута;
		КонецЕсли;
	КонецЦикла;

	Возврат ЗаписьКуки;

КонецФункции

// Новая запись куки.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - Запись куки
Функция НоваяЗаписьКуки()
	Запись = Новый Соответствие(); // Соответствие из КлючИЗначение
	Запись.Вставить("Name");
	Запись.Вставить("Value");
	
	Для Каждого КлючЗначение Из АтрибутыКуки() Цикл
		Запись.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;	
	
	Возврат Запись;
КонецФункции

Функция ЭтоАтрибутКуки(Знач Имя)
	
	Имя = НРег(Имя);

	Для Каждого КлючЗначение Из АтрибутыКуки() Цикл
		Если Имя = НРег(КлючЗначение.Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция АтрибутыКуки()
	Результат = Новый Соответствие(); // Соответствие из КлючИЗначение
	Результат.Вставить("Domain");
	Результат.Вставить("Expires");	
	Результат.Вставить("Path");
	Результат.Вставить("SameSite");
	Результат.Вставить("Secure", Ложь);
	Результат.Вставить("HttpOnly", Ложь);
	Результат.Вставить("Max-Age");	
	Результат.Вставить("Partitioned", Ложь);
	Результат.Вставить("Priority");
	Возврат Результат;
КонецФункции

// Нормализованное имя атрибута куки.
// 
// Параметры:
//  Имя - Строка - Имя
// 
// Возвращаемое значение:
//  Строка - Нормализованное имя атрибута куки
Функция НормализованноеИмяАтрибутаКуки(Знач Имя)

	Имя = НРег(Имя);
	
	Для Каждого КлючЗначение Из АтрибутыКуки() Цикл
		Если Имя = НРег(КлючЗначение.Ключ) Тогда
			Возврат КлючЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Имя;
	
КонецФункции

#КонецОбласти

#Область Эмуляция

// Эмуляция chrome.
// 
// Параметры:
//  Опции - Соответствие из КлючИЗначение - Опции команды curl
Процедура ЭмуляцияChrome(Опции)
	
	Если Не ЭтоHTTP() Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьЗаголовкиChrome();
	ДобавитьШифрыChrome();
	
	Если Не ПеренаправлятьЗапросПоНовомуURI Тогда
		ПеренаправлятьЗапрос();
	КонецЕсли;
	
	ДобавитьОпциюВСписок(Опции, "--http2");
	ДобавитьОпциюВСписок(Опции, "--tlsv1.2");
	ДобавитьОпциюВСписок(Опции, "--compressed");
	
КонецПроцедуры

Функция УстановитьЗаголовкиChrome()
	Заголовки = ПолучитьМакет("ChromeHeaders").ПолучитьТекст(); 
	УстановитьЗаголовки(Заголовки);
	Возврат ЭтотОбъект();
КонецФункции

// Добавляет шифры chrome в набор.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ДобавитьШифрыChrome()
	НаборШифров.Очистить();
	Возврат ДобавитьШифры("TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-CHACHA20-POLY1305,ECDHE-RSA-CHACHA20-POLY1305,ECDHE-RSA-AES128-SHA,ECDHE-RSA-AES256-SHA,AES128-GCM-SHA256,AES256-GCM-SHA384,AES128-SHA,AES256-SHA");
КонецФункции

#КонецОбласти

#Область ОбщегоНазначения

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
Функция ТолькоЦифрыВСтроке(Знач Значение, Знач ПробелыЗапрещены = Истина) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПробелыЗапрещены Тогда
		Значение = СтрЗаменить(Значение, " ", "");
	КонецЕсли;
		
	Если СтрДлина(Значение) = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0;
	
КонецФункции

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив из Произвольный - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив из Произвольный - массив значений для заполнения.
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения.
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь)
	
	Если ТолькоУникальныеЗначения Тогда
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
		
		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Дополняет соответствие значениями из другого соответствия.
//
// Параметры:
//   Приемник - Соответствие из КлючИЗначение - коллекция, в которую будут добавляться новые значения.
//   Источник - Соответствие из КлючИЗначение - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСоответствие(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник[Элемент.Ключ] <> Неопределено Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Пересечение ключей источника и приемника: ""%1"".'"), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно, 
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов 
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Структура
//           - Соответствие из КлючИЗначение
//           - Массив из Произвольный
//           - СписокЗначений из Произвольный
//           - ТаблицаЗначений - объект, который необходимо скопировать.
//
// Возвращаемое значение:
//  - Структура
//  - Соответствие из КлючИЗначение
//  - Массив из Произвольный
//  - СписокЗначений из Произвольный
//  - ТаблицаЗначений - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьРекурсивно(Источник)
	
	Перем Приемник; // Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений
	
	ТипИсточника = ТипЗнч(Источник);
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Возврат Источник.Скопировать();
	КонецЕсли;
#КонецЕсли	
	Если ТипИсточника = Тип("Структура") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		//@skip-check statement-type-change
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		//@skip-check statement-type-change
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		//@skip-check statement-type-change
		Приемник = СкопироватьСписокЗначений(Источник);
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Создает копию значения типа Структура, рекурсивно, с учетом типов значений свойств. 
// Если свойства структуры содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СтруктураИсточник - Структура - копируемая структура.
// 
// Возвращаемое значение:
//  Структура - копия исходной структуры.
//
Функция СкопироватьСтруктуру(СтруктураИсточник)
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение Из СтруктураИсточник Цикл
		Значение = КлючИЗначение.Значение; // Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(Значение));
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие, рекурсивно, с учетом типов значений.
// Если значения соответствия содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СоответствиеИсточник - Соответствие из КлючИЗначение - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник)
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		Значение = КлючИЗначение.Значение; // Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив, рекурсивно, с учетом типов значений элементов массива.
// Если элементы массива содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  МассивИсточник - Массив из Произвольный - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив из Произвольный - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив; // Массив из Произвольный
	
	Для Каждого Элемент Из МассивИсточник Цикл
		//@skip-check typed-value-adding-to-untyped-collection
		//@skip-check invocation-parameter-type-intersect
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений, рекурсивно, с учетом типов его значений.
// Если в списке значений есть значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СписокИсточник - СписокЗначений из Произвольный - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений из Произвольный - копия исходного списка значений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		//@skip-check typed-value-adding-to-untyped-collection
		//@skip-check invocation-parameter-type-intersect
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

Функция ЭтоWindows() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86 
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64;
	
КонецФункции

Функция ЭтоLinux() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Возвращаемое значение:
//  Булево - Истина, если файловая.
//
Функция ИнформационнаяБазаФайловая()
	СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Инициализация

УстановитьНачальныеНастройки();

#КонецОбласти

#КонецЕсли